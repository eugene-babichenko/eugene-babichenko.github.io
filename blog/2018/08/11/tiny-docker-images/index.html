<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://eugene-babichenko.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>Eugene Babichenko | Building tiny Docker images with multi-stage builds</title><link as=style href=https://eugene-babichenko.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/style.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/custom.css rel=stylesheet><link href=https://eugene-babichenko.github.io/favicon.ico rel=icon><body><nav id=nav-bar><a href=/> /home/ </a><a href=/blog> /blog/ </a><a href=https://github.com/eugene-babichenko> /github/ </a><a href=https://standwithukraine.com.ua/> /ðŸ‡ºðŸ‡¦ Support Ukraine/ </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://eugene-babichenko.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://eugene-babichenko.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2018-08-11T18:42:00+03:00>Published on: <span class=accent-data>2018-08-11</span> </time><h1>Building tiny Docker images with multi-stage builds</h1></header><div class=post-content><p>The big issue with Docker images is that they tend to get <strong>really</strong> big. Big projects can have so much build time dependencies and generated garbage that we may end up with images of, let's say, from thousands of megabytes to gigabytes. This can make virtualization pretty painful because it hurts just to wait until the image is downloaded from a Docker registry.<p>What can help us to get around those issues?<p>Let's start with an example. Suppose we have a Python application that uses some crypto stuff and runs a web server inside of it.<p>So here is our <code>Dockerfile</code>:<pre class=language-dockerfile data-lang=dockerfile style=color:#c0c5ce;background-color:#2b303b><code class=language-dockerfile data-lang=dockerfile><span style=color:#65737e># This base image contains stuff like OpenSSL and all of *-dev libraries
</span><span style=color:#b48ead>FROM</span><span> python:latest
</span><span style=color:#b48ead>WORKDIR </span><span>/project
</span><span>
</span><span style=color:#65737e># Copy and install the list of dependencies separately to speed the things up
</span><span style=color:#b48ead>COPY</span><span> ./requirements.txt .
</span><span style=color:#b48ead>RUN </span><span>pip3 install -r ./requirements.txt
</span><span>
</span><span style=color:#65737e># The rest is not interesting for us
</span></code></pre><p>And this is our <code>requirements.txt</code>:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>cryptography
</span><span>aiohttp
</span></code></pre><p>Pretty simple, huh? However, when we build this and check out the size of the image we have... Oops, <strong>956MB</strong> for a project with only two explicitly specified dependencies.<p>What we can do is to move to a slimmer base image. The best fit for Docker images is <a href=https://alpinelinux.org/>Alpine Linux</a>. With only Busybox, <a href=https://www.musl-libc.org/>musl</a> (libc implementation), <a href=https://www.libressl.org/>libressl</a> (OpenSSL compatible crypto) and apk (package manager) it is <strong>5MB</strong> unpacked.<pre class=language-dockerfile data-lang=dockerfile style=color:#c0c5ce;background-color:#2b303b><code class=language-dockerfile data-lang=dockerfile><span style=color:#b48ead>FROM</span><span> alpine:edge
</span><span style=color:#b48ead>RUN </span><span>apk --update --no-cache add pkgconf build-base autoconf automake python3 python3-dev libffi-dev libressl-dev
</span><span style=color:#b48ead>COPY</span><span> ./requirements.txt .
</span><span style=color:#b48ead>RUN </span><span>pip3 install -r ./requirements.txt
</span></code></pre><p>Here we need to handle a lot of dependencies manually, but now it's <strong>295MB</strong>. We just cut down our image by more than <strong>3 times</strong>!<p>Now we can move further. We definitely don't need all of the dependencies that are required for building the project. Here are two options for how to deal with them:<ol><li>Remove them manually (apk even have syntactic sugar for that called virtual packages) and then squash layers together by using software like <a href=https://github.com/jwilder/docker-squash>docker-squash</a>.<li>Instead, we can use the feature of Docker called <a href=https://docs.docker.com/develop/develop-images/multistage-build/>multi-stage builds</a>.</ol><p>The last variant seems better because it doesn't involve additional software, so let's try it:<pre class=language-dockerfile data-lang=dockerfile style=color:#c0c5ce;background-color:#2b303b><code class=language-dockerfile data-lang=dockerfile><span style=color:#65737e># In this stage called `build` we install just everything and build the project.
</span><span style=color:#b48ead>FROM</span><span> alpine:edge </span><span style=color:#b48ead>as </span><span style=color:#bf616a>build
</span><span style=color:#b48ead>RUN </span><span>apk --update --no-cache add pkgconf build-base autoconf automake python3 python3-dev libffi-dev libressl-dev
</span><span style=color:#65737e># Create a custom directory for installing Python packages
</span><span style=color:#b48ead>RUN </span><span>mkdir /install
</span><span style=color:#b48ead>ENV </span><span>PYTHONUSERBASE=/install
</span><span style=color:#b48ead>COPY</span><span> ./requirements.txt .
</span><span style=color:#b48ead>RUN </span><span>pip3 install --user -r ./requirements.txt
</span><span>
</span><span style=color:#65737e># Start an image from scratch...
</span><span style=color:#b48ead>FROM</span><span> alpine:edge </span><span style=color:#b48ead>as </span><span style=color:#bf616a>release
</span><span style=color:#65737e># Install only necessary dependencies
</span><span style=color:#b48ead>RUN </span><span>apk --update --no-cache add python3 libffi
</span><span style=color:#65737e># Copy installed dependencies from the previous stage
</span><span style=color:#b48ead>COPY</span><span> --from=</span><span style=color:#bf616a>build</span><span> /install /install
</span><span style=color:#b48ead>ENV </span><span>PYTHONUSERBASE=/install
</span></code></pre><p>And now we have just <strong>70.5MB</strong>! The image size was cut down <strong>more than 10 times</strong>.<p>To sum up, the approach for building a minimal Docker image is the following:<ol><li>Use some minimal image as the base. Alpine Linux is a good one.<li>Create a build stage with all of the dependencies required for both building and running your software.<li>Build your software in this image.<li>Then create a separate build stage from the base image.<li>Install the minimal set of dependencies required for running your application.<li>Use the <code>copy from</code> feature to copy the built software to the release image.<li>...<li>PROFIT</ol></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme.<p><a title="face icons" href=https://www.flaticon.com/free-icons/face>Face icons created by Freepik - Flaticon</a><p>Â© 2018-2025 Eugene Babichenko</div></footer><script defer src=https://eugene-babichenko.github.io/js/script.js></script>
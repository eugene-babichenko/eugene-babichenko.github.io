<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://eugene-babichenko.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>Eugene Babichenko | Convenient Rust crates with procedural macros and runnable code</title><link as=style href=https://eugene-babichenko.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/style.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/custom.css rel=stylesheet><link href=https://eugene-babichenko.github.io/favicon.ico rel=icon><body><nav id=nav-bar><a href=/> /home/ </a><a href=/blog> /blog/ </a><a href=https://github.com/eugene-babichenko> /github/ </a><a href=https://standwithukraine.com.ua/> /ðŸ‡ºðŸ‡¦ Support Ukraine/ </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://eugene-babichenko.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://eugene-babichenko.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2019-05-22T13:00:00+03:00>Published on: <span class=accent-data>2019-05-22</span> </time><h1>Convenient Rust crates with procedural macros and runnable code</h1></header><div class=post-content><p>Procedural macros in Rust are a great thing for many purposes (implementing custom derives, domain-specific languages inside Rust, etc). However, the use of procedural macros imposes one very inconvenient constraint: a crate that defines procedural macros can export nothing but procedural macros. This usually leads us to usi multiple crates to do exactly one thing (remember <code>serde</code> and <code>serde_derive</code>?). In this article, I will review an approach to this problem I have seen in the <a href=https://github.com/rust-lang-nursery/failure><code>failure</code></a> crate that allows us to import exactly one crate.<h2 id=the-project-structure>The project structure</h2><p>All libraries I have seen so far rely on workspaces when they need to build a "simple" crate and a <code>proc-macro</code> crate. The generic structure for that is:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>workspace
</span><span>â”œâ”€â”€ lib_crate/
</span><span>â”œâ”€â”€ proc_macro_crate/
</span><span>â””â”€â”€ Cargo.toml
</span></code></pre><p>with <code>Cargo.toml</code> that looks like that:<pre class=language-toml data-lang=toml style=color:#c0c5ce;background-color:#2b303b><code class=language-toml data-lang=toml><span>[workspace]
</span><span style=color:#bf616a>members </span><span>=  ["</span><span style=color:#a3be8c>lib_crate</span><span>", "</span><span style=color:#a3be8c>proc_macro_crate</span><span>"]
</span></code></pre><p>Usually, <code>lib_crate</code> contains the definitions of traits, structures and procedures and <code>proc_macro_crate</code> contains procedural macros that generate code which reuses definitions from <code>lib_crate</code>.<h2 id=the-actual-trick>The actual trick</h2><p>In many libraries what you need to do is to import two crates:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>#[</span><span style=color:#bf616a>macro_use</span><span>]
</span><span style=color:#b48ead>extern crate</span><span> proc_macro_crate;
</span><span style=color:#b48ead>extern crate</span><span> lib_crate;
</span></code></pre><p>If you don't want your users to do that, you can use a pretty simple hack. Cargo does not prohibit to re-export procedural macros, so you can just re-export them in your <code>lib_crate</code>!<p><code>lib_crate/Cargo.toml</code>:<pre class=language-toml data-lang=toml style=color:#c0c5ce;background-color:#2b303b><code class=language-toml data-lang=toml><span>[dependencies]
</span><span style=color:#bf616a>proc_macro_crate </span><span>= { </span><span style=color:#bf616a>path </span><span>= "</span><span style=color:#a3be8c>../proc_macro_crate</span><span>", </span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>0.1.0</span><span>" }
</span></code></pre><p><code>lib_crate/src/lib.rs</code>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>#[</span><span style=color:#bf616a>macro_use</span><span>]
</span><span style=color:#b48ead>extern crate</span><span> proc_macro_crate;
</span><span>
</span><span style=color:#b48ead>pub use </span><span>proc_macro_crate::*;
</span></code></pre><p>As they do not need to import two separate crates anymore <code>Cargo.toml</code> and their code look a bit cleaner.</div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme.<p><a title="face icons" href=https://www.flaticon.com/free-icons/face>Face icons created by Freepik - Flaticon</a><p>Â© 2018-2025 Eugene Babichenko</div></footer><script defer src=https://eugene-babichenko.github.io/js/script.js></script>
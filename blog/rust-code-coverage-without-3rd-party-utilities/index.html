<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://eugene-babichenko.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>Eugene Babichenko | Rust code coverage without 3rd party utilities</title><link as=style href=https://eugene-babichenko.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/style.css rel=stylesheet><link href=https://eugene-babichenko.github.io/css/custom.css rel=stylesheet><link href=https://eugene-babichenko.github.io/favicon.ico rel=icon><body><nav id=nav-bar><a href=/> /home/ </a><a href=/blog> /blog/ </a><a href=https://github.com/eugene-babichenko> /github/ </a><a href=https://standwithukraine.com.ua/> /ðŸ‡ºðŸ‡¦ Support Ukraine/ </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://eugene-babichenko.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://eugene-babichenko.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-11-15T22:00:00+02:00>Published on: <span class=accent-data>2024-11-15</span> </time><h1>Rust code coverage without 3rd party utilities</h1></header><div class=toc-container><h2>Table of content</h2><ul><li><a href=https://eugene-babichenko.github.io/blog/rust-code-coverage-without-3rd-party-utilities/#the-basics>The Basics</a><li><a href=https://eugene-babichenko.github.io/blog/rust-code-coverage-without-3rd-party-utilities/#lcov-and-interfacing-with-code-coverage-services>lcov and interfacing with code coverage services</a></ul></div><div class=post-content><p>Today I got fed up with my CI being slow and dealing with 3rd party software. So I decided to finally give a read to the amazing <a href=https://doc.rust-lang.org/rustc/instrument-coverage.html>"Instrumentation-based Code Coverage"</a> article from the rustc book. And while it is pretty exhaustive, some parts of it are not very up to date, some may be done nicer (e.g. without the use of 3rd party tools in your CI), and some important practical aspects are not covered by it at all (interfacing with code coverage services). So let's dive into it!<h2 id=the-basics>The Basics</h2><p>The entire approach is built around LLVM <a href=https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>source-based code coverage instrumentation</a>. This thing is fairly straightforward: you add a flag when building your program and when you run it, it outputs the profiling information. For Rust it is done like that:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#b48ead>export </span><span style=color:#bf616a>RUSTFLAGS</span><span>="</span><span style=color:#a3be8c>-C instrument-coverage</span><span>"
</span><span style=color:#bf616a>cargo</span><span> test </span><span style=color:#65737e># or cargo build, or cargo run
</span></code></pre><p>If you check your project directory after running this, you will see one more files that look like this:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>default_16297040162499240015_0_10889.profraw
</span></code></pre><p>These are outputs from the profiler instrumentation that got built into your application and test binaries.<p>By themselves, they are not of much use and we need to generate a <em>profile data file</em>. For that, we need the tools:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>rustup</span><span> component add llvm-tools
</span></code></pre><p>In theory, we could use the tools that come with the standard LLVM distribution. But we have something guaranteed to work with what rustc produces, so why bother? Anyway, at this point the rustc book recommends us to install <code>cargo-binutils</code>. This tool is needed because <code>llvm-tools</code> don't get exposed via the <code>PATH</code> variable to avoid conflicts with the actual LLVM installation that may be present in your system. And I am not against convenience, but when running inside of CI this convenience becomes a liability: this is something that takes time to install and is a potential security hole.<p>So, after a couple of iterations and with the help of the power of Reddit I have this (<a href=https://www.reddit.com/r/rust/comments/1gs5jyl/comment/lxczfok/>this comment</a>):<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>PATH</span><span>="$</span><span style=color:#a3be8c>(</span><span style=color:#bf616a>rustc --print</span><span>=</span><span style=color:#a3be8c>target-libdir)/../bin:</span><span>$</span><span style=color:#bf616a>PATH</span><span>"
</span></code></pre><p>With that out of the way, we can finally build the needed file:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>llvm-profdata</span><span> merge</span><span style=color:#bf616a> -sparse</span><span> default_*.profraw</span><span style=color:#bf616a> -o</span><span> tests.profdata
</span></code></pre><p>And <code>tests.profdata</code> is going to be the source of any visualization we want to do.<p>First, let's try and output a simple table with code coverage data per file and a summary per the rustc book recommendations:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>llvm-cov</span><span> report</span><span style=color:#bf616a> --use-color --ignore-filename-regex</span><span>='</span><span style=color:#a3be8c>/.cargo/registry</span><span>'</span><span style=color:#bf616a> -instr-profile</span><span> tests.profdata $</span><span style=color:#bf616a>objects
</span></code></pre><p>But hey, what is this <code>objects</code> variable? Well, you need to list the test binaries in the format of <code>--object &LTbinary></code>. And this is our second deviation from the rustc book, since their recommendation simply doesn't work. So this is what I came up with:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>objects</span><span>="$</span><span style=color:#a3be8c>(</span><span style=color:#bf616a>cargo</span><span style=color:#a3be8c> test</span><span style=color:#bf616a> --no-run --message-format</span><span>=</span><span style=color:#a3be8c>json </span><span>| </span><span style=color:#bf616a>jq -r </span><span>'</span><span style=color:#a3be8c>select(.profile.test == true) | .filenames[] | "--object " + .</span><span>' | </span><span style=color:#bf616a>tr </span><span>'</span><span style=color:#a3be8c>\n</span><span>' ' '</span><span style=color:#a3be8c>)</span><span>"
</span></code></pre><p>What this line does is:<ul><li>Take the json output of <code>cargo test</code> without actually running the tests.<li>Extract the names of the test binaries adding the <code>--object</code> flag in the process.<li>Turn it into a single line.</ul><p>Yes, yes, I can hear you. I promised "no third party tools" and now <code>jq</code> pops up. But it is included in the GitHub Actions environment out of the box and almost everyone has it installed anyway, so that doesn't count ðŸ˜œ.<p>Now that we have <code>objects</code>, we can run <code>llvm-cov</code> and see a nice table with our coverage data. I'll leave it up to you to figure out generating nice and shiny HTML reports.<h2 id=lcov-and-interfacing-with-code-coverage-services><code>lcov</code> and interfacing with code coverage services</h2><p>Now, let's get to another thing not covered by the rustc book: interfacing with code coverage services like <a href=https://coveralls.io/>Coveralls</a> (unfortunately, they don't pay me). These things are nice, because they give everyone a shared look into the code coverage data retrieved in a controlled environment (e.g. CI). For Coveralls we would need to convert out <code>.profdata</code> into something that Coveralls can actually consume. I went with <code>lcov</code> and this is a rather simple conversion:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>llvm-cov</span><span> export</span><span style=color:#bf616a> -format</span><span>=lcov</span><span style=color:#bf616a> -instr-profile</span><span> tests.profdata $</span><span style=color:#bf616a>objects -sources</span><span> src/{,**/}*.rs > tests.lcov
</span></code></pre><p>In GitHub Actions we can just use the Coveralls action with the default setup:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span>- </span><span style=color:#bf616a>name</span><span>: </span><span style=color:#a3be8c>Upload coverage report
</span><span>  </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>coverallsapp/github-action@v2
</span><span>    </span><span style=color:#bf616a>with</span><span>:
</span><span>      </span><span style=color:#bf616a>github-token</span><span>: </span><span style=color:#a3be8c>${{ secrets.GITHUB_TOKEN }}
</span></code></pre></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme.<p><a title="face icons" href=https://www.flaticon.com/free-icons/face>Face icons created by Freepik - Flaticon</a><p>Â© 2018-2025 Eugene Babichenko</div></footer><script defer src=https://eugene-babichenko.github.io/js/script.js></script>